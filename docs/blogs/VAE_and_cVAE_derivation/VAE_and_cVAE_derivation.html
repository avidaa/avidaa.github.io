<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>vae_and_cvae_derivation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-d045e70ebd9269c25e164ecdb4898f56.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Avid Afzal</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blogs.html"> 
<span class="menu-text">Blogs</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#mathematical-derivation-of-vae" id="toc-mathematical-derivation-of-vae" class="nav-link active" data-scroll-target="#mathematical-derivation-of-vae">Mathematical Derivation of VAE</a>
  <ul class="collapse">
  <li><a href="#what-is-the-aim-of-blog" id="toc-what-is-the-aim-of-blog" class="nav-link" data-scroll-target="#what-is-the-aim-of-blog">What is the aim of blog?</a></li>
  <li><a href="#introduction-what-are-variational-autoencoders-vaes" id="toc-introduction-what-are-variational-autoencoders-vaes" class="nav-link" data-scroll-target="#introduction-what-are-variational-autoencoders-vaes">Introduction: What are Variational Autoencoders (VAEs)?</a></li>
  <li><a href="#intuition-what-a-vae-is-really-learning" id="toc-intuition-what-a-vae-is-really-learning" class="nav-link" data-scroll-target="#intuition-what-a-vae-is-really-learning">Intuition: What a VAE Is Really Learning</a></li>
  <li><a href="#what-are-the-assumptions-of-a-vae-model" id="toc-what-are-the-assumptions-of-a-vae-model" class="nav-link" data-scroll-target="#what-are-the-assumptions-of-a-vae-model">What are the assumptions of a VAE model?</a></li>
  <li><a href="#what-is-the-role-of-vaes-encoder-and-decoder" id="toc-what-is-the-role-of-vaes-encoder-and-decoder" class="nav-link" data-scroll-target="#what-is-the-role-of-vaes-encoder-and-decoder">What is the role of VAE’s encoder and decoder?</a></li>
  <li><a href="#how-can-we-learn-colorgreenphi-and-colorbluetheta-jointly" id="toc-how-can-we-learn-colorgreenphi-and-colorbluetheta-jointly" class="nav-link" data-scroll-target="#how-can-we-learn-colorgreenphi-and-colorbluetheta-jointly">How can we learn <span class="math inline">\(\color{green}{\phi}\)</span> and <span class="math inline">\(\color{blue}{\theta}\)</span> jointly?</a></li>
  <li><a href="#deriving-the-evidence-lower-bound-elbo" id="toc-deriving-the-evidence-lower-bound-elbo" class="nav-link" data-scroll-target="#deriving-the-evidence-lower-bound-elbo">Deriving the Evidence Lower Bound (ELBO)</a></li>
  <li><a href="#key-takeaways-and-final-remarks" id="toc-key-takeaways-and-final-remarks" class="nav-link" data-scroll-target="#key-takeaways-and-final-remarks">Key Takeaways and Final Remarks</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="mathematical-derivation-of-vae" class="level1">
<h1>Mathematical Derivation of VAE</h1>
<section id="what-is-the-aim-of-blog" class="level3">
<h3 class="anchored" data-anchor-id="what-is-the-aim-of-blog">What is the aim of blog?</h3>
<p>This blog draws upon insights from <a href="https://hunterheidenreich.com/posts/modern-variational-autoencoder-in-pytorch/">this article</a> and <a href="https://lilianweng.github.io/posts/2018-08-12-vae/#td-vae">this post</a>, with the objective of developing a deeper and more technical understanding of Variational Autoencoders (VAEs).</p>
</section>
<section id="introduction-what-are-variational-autoencoders-vaes" class="level3">
<h3 class="anchored" data-anchor-id="introduction-what-are-variational-autoencoders-vaes">Introduction: What are Variational Autoencoders (VAEs)?</h3>
<p>Variational Autoencoders (VAEs) are a foundational class of latent variable models that combine probabilistic modeling with neural networks, enabling <strong>both representation learning and data generation</strong>. Unlike standard autoencoders, VAEs provide a principled probabilistic framework that allows us to reason about uncertainty, impose structure on latent spaces, and perform meaningful sampling.</p>
<p>At a high level, VAEs assume that high-dimensional observations are generated from a lower-dimensional latent variable through a stochastic process. Learning such models, however, presents a central challenge: <em>the true posterior distribution over latent variables is intractable</em>. Variational inference resolves this by introducing a tractable approximation and reframing learning as an optimization problem.</p>
<p>The goal of this post is to develop a precise and fully mathematical understanding of how VAEs are derived—from their generative assumptions to the Evidence Lower Bound (ELBO) that is optimized in practice. Rather than focusing on intuition alone, we walk through each step of the derivation, clarifying where approximations are introduced and why the final objective is both computable and effective.</p>
</section>
<section id="intuition-what-a-vae-is-really-learning" class="level3">
<h3 class="anchored" data-anchor-id="intuition-what-a-vae-is-really-learning">Intuition: What a VAE Is Really Learning</h3>
<p>A VAE assumes that each data point can be explained by a small set of hidden factors—latent variables—that capture the essential structure of the data.</p>
<p>The encoder does not map an input to a single point in latent space, but instead learns <strong>a distribution over plausible latent representations</strong>, reflecting uncertainty about how the data was generated.</p>
<p>The decoder then learns how to <strong>probabilistically reconstruct the data from samples drawn from this latent distribution</strong>.</p>
<p>Training a VAE is therefore a balancing act: we want latent representations that are expressive enough to reconstruct the data well, while also being regularized to follow a simple prior distribution so that the latent space remains smooth and generative.</p>
</section>
<section id="what-are-the-assumptions-of-a-vae-model" class="level3">
<h3 class="anchored" data-anchor-id="what-are-the-assumptions-of-a-vae-model">What are the assumptions of a VAE model?</h3>
<p>Assume we have a dataset <span class="math inline">\(X\)</span>:</p>
<p><span class="math display">\[X = [\vec{x}^{(i)}]_{i=1}^N = \{\vec{x}^{(1)}, \vec{x}^{(2)}, \ldots, \vec{x}^{(N)}\}\]</span></p>
<p>Each <span class="math inline">\(\vec{x}^{(i)}\)</span> is IID. It can be continuous or discrete-valued.</p>
<p><strong>Key Generative Assumptions:</strong></p>
<p>The VAE framework makes the following fundamental assumptions about how the observed data is generated:</p>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Assumption 1: Latent Prior Distribution
</div>
</div>
<div class="callout-body-container callout-body">
<p>Each latent vector <span class="math inline">\(\vec{z}^{(i)}\)</span> is drawn from a <strong>prior distribution</strong>:</p>
<p><span class="math display">\[\vec{z}^{(i)} \sim \color{purple}{p_{\theta^*}(\vec{z})}\]</span></p>
<p>where <span class="math inline">\(\color{purple}{p_{\theta^*}(\vec{z})}\)</span> is the <span class="math inline">\(\color{purple}{\text{prior}}\)</span> over the lower-dimensional latent space, parameterized by <span class="math inline">\(\color{purple}{\theta^*}\)</span>.</p>
</div>
</div>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Assumption 2: Conditional Likelihood
</div>
</div>
<div class="callout-body-container callout-body">
<p>Each observed data point is generated from its corresponding latent vector through a <strong>conditional distribution</strong>:</p>
<p><span class="math display">\[\vec{x}^{(i)} \sim \color{blue}{p_{\theta^*}(\vec{x} \mid \vec{z} = \vec{z}^{(i)})}\]</span></p>
<p>where <span class="math inline">\(\color{blue}{p_{\theta^*}(\vec{x} \mid \vec{z})}\)</span> is the model’s <span class="math inline">\(\color{blue}{\text{likelihood}}\)</span> function, representing the probability of generating <span class="math inline">\(\vec{x}\)</span> given latent code <span class="math inline">\(\vec{z}\)</span>.</p>
</div>
</div>
<p>In essence, we assume the observed high-dimensional dataset <span class="math inline">\(X\)</span> is generated by a <strong>latent variable model</strong> with an underlying lower-dimensional random process <span class="math inline">\(\vec{z}\)</span>.</p>
<p>The goal is to find the parameter <span class="math inline">\(\color{purple}{\theta^*}\)</span> that makes our observed data as likely as possible under the model. In other words, we want to maximize the likelihood of the data:</p>
<p><span class="math display">\[\color{purple}{\theta^*} {\color{black}{= \arg \max_{\theta}\prod_{i=1}^N}} \color{teal}{p_\theta(\vec{x}^{(i)})}\]</span></p>
<p>However, it is usually more convenient and numerically stable to work with the log-likelihood (since logs turn products into sums). Therefore, we rewrite the objective as:</p>
<p><span class="math display">\[\color{purple}{\theta^*} \color{black}{ = \arg \max_{\theta}\sum_{i=1}^N \log} \; \color{teal}{p_\theta(\vec{x}^{(i)})}\]</span></p>
<p>To compute <span class="math inline">\(\color{teal}{p_\theta(\vec{x}^{i})}\)</span>, we marginalize over the latent variable <span class="math inline">\(z\)</span>:</p>
<p><span class="math display">\[\color{teal}{p_\theta(\vec{x}^{i})} = \int \color{blue}{p_\theta(x|z)}\, \color{orange}{p_\theta(z)}\, dz\]</span></p>
<p>However, directly computing this integral is typically <strong>intractable</strong> because it requires evaluating <span class="math inline">\(p_\theta(x|z)\)</span> for all possible values of <span class="math inline">\(z\)</span>. To make this computation practical, we introduce an auxiliary function, <span class="math inline">\(\color{green}{q_\phi(z|x)}\)</span>, called the variational distribution or approximate posterior. This function, parameterized by <span class="math inline">\(\color{green}{\phi}\)</span>, provides a tractable way to estimate which values of <span class="math inline">\(z\)</span> are likely given a particular input <span class="math inline">\(x\)</span>.</p>
</section>
<section id="what-is-the-role-of-vaes-encoder-and-decoder" class="level3">
<h3 class="anchored" data-anchor-id="what-is-the-role-of-vaes-encoder-and-decoder">What is the role of VAE’s encoder and decoder?</h3>
<p>To understand the VAE architecture, let’s start with <strong>Bayes’ theorem</strong>, which relates our key distributions:</p>
<p><span class="math display">\[\color{red}{p_\theta(z|x)} = \frac{\color{orange}{p_\theta(z)} \times \color{blue}{p_\theta(x|z)}}{\color{teal}{p_\theta(x)}}\]</span></p>
<p>This equation shows that the <strong>posterior</strong> distribution <span class="math inline">\(\color{red}{p_\theta(z|x)}\)</span> (the probability of latent code <span class="math inline">\(z\)</span> given observation <span class="math inline">\(x\)</span>) can be computed from the prior <span class="math inline">\(\color{orange}{p_\theta(z)}\)</span>, the likelihood <span class="math inline">\(\color{blue}{p_\theta(x|z)}\)</span>, and the evidence <span class="math inline">\(\color{teal}{p_\theta(x)}\)</span>.</p>
<section id="the-challenge-intractable-posterior" class="level4">
<h4 class="anchored" data-anchor-id="the-challenge-intractable-posterior">The Challenge: Intractable Posterior</h4>
<p>The posterior <span class="math inline">\(\color{red}{p_\theta(z|x)}\)</span> is <strong>intractable</strong> to compute directly because it requires knowing <span class="math inline">\(\color{teal}{p_\theta(x)}\)</span>, which involves the difficult integral we discussed earlier. This is where the VAE’s two-part architecture comes in:</p>
<div class="callout callout-style-default callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The Encoder (Recognition Network)
</div>
</div>
<div class="callout-body-container callout-body">
<p>The <strong>encoder</strong> approximates the intractable posterior <span class="math inline">\(\color{red}{p_\theta(z|x)}\)</span> using variational inference.</p>
<ul>
<li>We introduce a <strong>variational distribution</strong> <span class="math inline">\(\color{green}{q_\phi(z|x)}\)</span> that is designed to be tractable</li>
<li>The encoder learns parameters <span class="math inline">\(\color{green}{\phi}\)</span> to make <span class="math inline">\(\color{green}{q_\phi(z|x)} \approx \color{red}{p_\theta(z|x)}\)</span> as close as possible</li>
<li><strong>Role</strong>: Given an input <span class="math inline">\(x\)</span>, the encoder outputs a distribution over likely latent codes <span class="math inline">\(z\)</span></li>
</ul>
</div>
</div>
<div class="callout callout-style-default callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The Decoder (Generative Network)
</div>
</div>
<div class="callout-body-container callout-body">
<p>The <strong>decoder</strong> models the likelihood <span class="math inline">\(\color{blue}{p_\theta(x|z)}\)</span>, which is the generative part of the model.</p>
<ul>
<li>The decoder learns parameters <span class="math inline">\(\color{blue}{\theta}\)</span> to map from the latent space back to the data space</li>
<li><strong>Role</strong>: Given a latent code <span class="math inline">\(z\)</span>, the decoder outputs a distribution over possible reconstructions <span class="math inline">\(x\)</span></li>
</ul>
</div>
</div>
<p>In summary: the encoder <strong>compresses</strong> observations <span class="math inline">\(x\)</span> into latent representations <span class="math inline">\(z\)</span>, while the decoder <strong>reconstructs</strong> observations from latent codes.</p>
</section>
</section>
<section id="how-can-we-learn-colorgreenphi-and-colorbluetheta-jointly" class="level3">
<h3 class="anchored" data-anchor-id="how-can-we-learn-colorgreenphi-and-colorbluetheta-jointly">How can we learn <span class="math inline">\(\color{green}{\phi}\)</span> and <span class="math inline">\(\color{blue}{\theta}\)</span> jointly?</h3>
<p>Now we have two sets of parameters to optimize:</p>
<ul>
<li><strong>Encoder parameters</strong> <span class="math inline">\(\color{green}{\phi}\)</span>: control the approximate posterior <span class="math inline">\(\color{green}{q_\phi(z|x)}\)</span></li>
<li><strong>Decoder parameters</strong> <span class="math inline">\(\color{blue}{\theta}\)</span>: control the likelihood <span class="math inline">\(\color{blue}{p_\theta(x|z)}\)</span> (and also appear in the true posterior <span class="math inline">\(\color{red}{p_\theta(z|x)}\)</span>)</li>
</ul>
<p>Our goal is to make the estimated posterior <span class="math inline">\(\color{green}{q_\phi(z|x)}\)</span> as close as possible to the true (but intractable) posterior <span class="math inline">\(\color{red}{p_\theta(z|x)}\)</span>.</p>
<section id="measuring-closeness-the-kl-divergence" class="level4">
<h4 class="anchored" data-anchor-id="measuring-closeness-the-kl-divergence">Measuring Closeness: The KL Divergence</h4>
<p>To measure how “close” two probability distributions are, we use the <strong>Kullback-Leibler (KL) divergence</strong>. Specifically, we use the <strong>reverse KL divergence</strong>:</p>
<p><span class="math display">\[\text{KL}\left(\color{green}{q_\phi(z|x)} \; || \; \color{red}{p_\theta(z|x)}\right) = \mathbb{E}_{z \sim \color{green}{q_\phi(z|x)}} \left[ \log \frac{\color{green}{q_\phi(z|x)}}{\color{red}{p_\theta(z|x)}} \right]\]</span></p>
<p>which can be written more explicitly as:</p>
<ul>
<li><p>For <strong>discrete</strong> latent variables: <span class="math display">\[\text{KL}\left(\color{green}{q_\phi(z|x)} \; || \; \color{red}{p_\theta(z|x)}\right) = \sum_{z \in Z} \color{green}{q_\phi(z|x)} \log \left( \frac{\color{green}{q_\phi(z|x)}}{\color{red}{p_\theta(z|x)}} \right)\]</span></p></li>
<li><p>For <strong>continuous</strong> latent variables: <span class="math display">\[\text{KL}\left(\color{green}{q_\phi(z|x)} \; || \; \color{red}{p_\theta(z|x)}\right) = \int \color{green}{q_\phi(z|x)} \log \left( \frac{\color{green}{q_\phi(z|x)}}{\color{red}{p_\theta(z|x)}} \right) dz\]</span></p></li>
</ul>
<div class="callout callout-style-default callout-important no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Key Properties of KL Divergence
</div>
</div>
<div class="callout-body-container callout-body">
<p>Understanding these properties is crucial for grasping how VAE training works:</p>
<p><strong>1. Non-negativity:</strong> <span class="math inline">\(\text{KL}(q \; || \; p) \geq 0\)</span> for any two distributions <span class="math inline">\(q\)</span> and <span class="math inline">\(p\)</span></p>
<ul>
<li>The KL divergence is always non-negative or zero</li>
<li>This property is fundamental and comes from Jensen’s inequality</li>
<li>Intuitively: there’s always some “cost” to using an approximation unless it’s exact</li>
</ul>
<p><strong>2. Zero if and only if distributions are identical:</strong> <span class="math inline">\(\text{KL}(q \; || \; p) = 0 \iff q = p\)</span> (almost everywhere)</p>
<ul>
<li>When <span class="math inline">\(q\)</span> and <span class="math inline">\(p\)</span> are exactly the same, there’s no information loss</li>
<li>This is our ideal case: <span class="math inline">\(\color{green}{q_\phi(z|x)} \color{black}{=} \color{red}{p_\theta(z|x)}\)</span></li>
<li>In practice, we get close but rarely achieve exactly zero</li>
</ul>
<p><strong>3. Asymmetric (not a distance metric):</strong> <span class="math inline">\(\text{KL}(q \; || \; p) \neq \text{KL}(p \; || \; q)\)</span> in general</p>
<ul>
<li>The order matters! <span class="math inline">\(\text{KL}(\color{green}{q_\phi} \; || \; \color{red}{p_\theta})\)</span> is called the <strong>reverse KL</strong></li>
<li>Reverse KL encourages <span class="math inline">\(q\)</span> to focus on regions where <span class="math inline">\(p\)</span> has high probability</li>
<li>This is why VAE tends to produce “mode-covering” behavior rather than “mode-seeking”</li>
</ul>
<p><strong>4. Measures information loss:</strong> It quantifies the expected extra bits (or nats) needed when using <span class="math inline">\(q\)</span> to encode samples from <span class="math inline">\(p\)</span></p>
<ul>
<li>In VAE context: how much information we lose by using <span class="math inline">\(\color{green}{q_\phi(z|x)}\)</span> instead of the true <span class="math inline">\(\color{red}{p_\theta(z|x)}\)</span></li>
</ul>
</div>
</div>
<p><strong>Our Training Objective:</strong></p>
<p>By <strong>minimizing</strong> <span class="math inline">\(\text{KL}\left(\color{green}{q_\phi(z|x)} \; || \; \color{red}{p_\theta(z|x)}\right)\)</span>, we make our encoder’s approximate posterior as accurate as possible. However, there’s a problem: we can’t directly compute this KL divergence because it involves the intractable posterior <span class="math inline">\(\color{red}{p_\theta(z|x)}\)</span>!</p>
<p>This is where the ELBO (Evidence Lower Bound) comes in, which we’ll derive next.</p>
</section>
</section>
<section id="deriving-the-evidence-lower-bound-elbo" class="level3">
<h3 class="anchored" data-anchor-id="deriving-the-evidence-lower-bound-elbo">Deriving the Evidence Lower Bound (ELBO)</h3>
<section id="the-problem-we-need-to-solve" class="level4">
<h4 class="anchored" data-anchor-id="the-problem-we-need-to-solve">The Problem We Need to Solve</h4>
<p>Recall that we want to minimize <span class="math inline">\(\text{KL}\left(\color{green}{q_\phi(z|x)} \; || \; \color{red}{p_\theta(z|x)}\right)\)</span>, but we can’t compute it directly because it involves the intractable posterior <span class="math inline">\(\color{red}{p_\theta(z|x)}\)</span>.</p>
<p>The variational inference idea is that we can derive an <strong>alternative objective</strong> that:</p>
<ol type="1">
<li>Is tractable to compute</li>
<li>Still allows us to optimize both <span class="math inline">\(\color{green}{\phi}\)</span> and <span class="math inline">\(\color{blue}{\theta}\)</span></li>
<li>Automatically handles the intractability</li>
</ol>
<p>Let’s derive this alternative objective step by step.</p>
</section>
<section id="step-1-start-with-the-kl-divergence" class="level4">
<h4 class="anchored" data-anchor-id="step-1-start-with-the-kl-divergence">Step 1: Start with the KL Divergence</h4>
<p>For continuous latent variables, the KL divergence is defined as:</p>
<p><span class="math display">\[\text{KL}\left(\color{green}{q_\phi(z|x)} \; || \; \color{red}{p_\theta(z|x)}\right) = \int \color{green}{q_\phi(z|x)} \log \left( \frac{\color{green}{q_\phi(z|x)}}{\color{red}{p_\theta(z|x)}} \right) dz\]</span></p>
</section>
<section id="step-2-apply-bayes-rule-to-the-posterior" class="level4">
<h4 class="anchored" data-anchor-id="step-2-apply-bayes-rule-to-the-posterior">Step 2: Apply Bayes’ Rule to the Posterior</h4>
<p>Using Bayes’ rule, we know that:</p>
<p><span class="math display">\[\color{red}{p_\theta(z|x)} = \frac{p_\theta(x,z)}{\color{teal}{p_\theta(x)}}\]</span></p>
<p>Substituting this into our KL divergence:</p>
<p><span class="math display">\[\text{KL}\left(\color{green}{q_\phi(z|x)} \; || \; \color{red}{p_\theta(z|x)}\right) = \int \color{green}{q_\phi(z|x)} \log \left( \frac{\color{green}{q_\phi(z|x)} \cdot \color{teal}{p_\theta(x)}}{p_\theta(x,z)} \right) dz\]</span></p>
</section>
<section id="step-3-split-the-logarithm" class="level4">
<h4 class="anchored" data-anchor-id="step-3-split-the-logarithm">Step 3: Split the Logarithm</h4>
<p>Using the property <span class="math inline">\(\log(ab/c) = \log(a) + \log(b) - \log(c)\)</span>:</p>
<p><span class="math display">\[\text{KL}\left(\color{green}{q_\phi(z|x)} \; || \; \color{red}{p_\theta(z|x)}\right) = \int \color{green}{q_\phi(z|x)} \left[ \log(\color{teal}{p_\theta(x)}) + \log \left( \frac{\color{green}{q_\phi(z|x)}}{p_\theta(x,z)} \right) \right] dz\]</span></p>
</section>
<section id="step-4-separate-the-integral" class="level4">
<h4 class="anchored" data-anchor-id="step-4-separate-the-integral">Step 4: Separate the Integral</h4>
<p>Split into two integrals:</p>
<p><span class="math display">\[\text{KL}\left(\color{green}{q_\phi(z|x)} \; || \; \color{red}{p_\theta(z|x)}\right) = \int \color{green}{q_\phi(z|x)} \log(\color{teal}{p_\theta(x)}) \, dz + \int \color{green}{q_\phi(z|x)} \log \left( \frac{\color{green}{q_\phi(z|x)}}{p_\theta(x,z)} \right) dz\]</span></p>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Key Observation: The Evidence is Constant
</div>
</div>
<div class="callout-body-container callout-body">
<p>The first integral simplifies because <span class="math inline">\(\color{teal}{p_\theta(x)}\)</span> doesn’t depend on <span class="math inline">\(z\)</span>:</p>
<p><span class="math display">\[\int \color{green}{q_\phi(z|x)} \log(\color{teal}{p_\theta(x)}) \, dz = \log(\color{teal}{p_\theta(x)}) \int \color{green}{q_\phi(z|x)} \, dz = \log(\color{teal}{p_\theta(x)})\]</span></p>
<p>since <span class="math inline">\(\int \color{green}{q_\phi(z|x)} \, dz = 1\)</span> (probability distributions must integrate to 1).</p>
</div>
</div>
<p>So now we have:</p>
<p><span class="math display">\[\text{KL}\left(\color{green}{q_\phi(z|x)} \; || \; \color{red}{p_\theta(z|x)}\right) = \log(\color{teal}{p_\theta(x)}) + \int \color{green}{q_\phi(z|x)} \log \left( \frac{\color{green}{q_\phi(z|x)}}{p_\theta(x,z)} \right) dz\]</span></p>
</section>
<section id="step-5-decompose-the-joint-distribution" class="level4">
<h4 class="anchored" data-anchor-id="step-5-decompose-the-joint-distribution">Step 5: Decompose the Joint Distribution</h4>
<p>The joint distribution can be factored as:</p>
<p><span class="math display">\[p_\theta(x,z) = \color{blue}{p_\theta(x|z)} \cdot \color{purple}{p_\theta(z)}\]</span></p>
<p>Substituting this:</p>
<p><span class="math display">\[\text{KL}\left(\color{green}{q_\phi(z|x)} \; || \; \color{red}{p_\theta(z|x)}\right) = \log(\color{teal}{p_\theta(x)}) + \int \color{green}{q_\phi(z|x)} \log \left( \frac{\color{green}{q_\phi(z|x)}}{\color{blue}{p_\theta(x|z)} \cdot \color{purple}{p_\theta(z)}} \right) dz\]</span></p>
</section>
<section id="step-6-simplify-using-logarithm-properties" class="level4">
<h4 class="anchored" data-anchor-id="step-6-simplify-using-logarithm-properties">Step 6: Simplify Using Logarithm Properties</h4>
<p>Using <span class="math inline">\(\log(a/(bc)) = \log(a/b) - \log(c)\)</span>:</p>
<p><span class="math display">\[\text{KL}\left(\color{green}{q_\phi(z|x)} \; || \; \color{red}{p_\theta(z|x)}\right) = \log(\color{teal}{p_\theta(x)}) + \int \color{green}{q_\phi(z|x)} \left[ \log \left( \frac{\color{green}{q_\phi(z|x)}}{\color{purple}{p_\theta(z)}} \right) - \log(\color{blue}{p_\theta(x|z)}) \right] dz\]</span></p>
</section>
<section id="step-7-split-into-two-integrals" class="level4">
<h4 class="anchored" data-anchor-id="step-7-split-into-two-integrals">Step 7: Split Into Two Integrals</h4>
<p><span class="math display">\[\text{KL}\left(\color{green}{q_\phi(z|x)} \; || \; \color{red}{p_\theta(z|x)}\right) = \log(\color{teal}{p_\theta(x)}) + \int \color{green}{q_\phi(z|x)} \log \left( \frac{\color{green}{q_\phi(z|x)}}{\color{purple}{p_\theta(z)}} \right) dz - \int \color{green}{q_\phi(z|x)} \log(\color{blue}{p_\theta(x|z)}) \, dz\]</span></p>
</section>
<section id="step-8-recognize-standard-forms" class="level4">
<h4 class="anchored" data-anchor-id="step-8-recognize-standard-forms">Step 8: Recognize Standard Forms</h4>
<p>The second term is the KL divergence between <span class="math inline">\(\color{green}{q_\phi(z|x)}\)</span> and the prior <span class="math inline">\(\color{purple}{p_\theta(z)}\)</span>:</p>
<p><span class="math display">\[\int \color{green}{q_\phi(z|x)} \log \left( \frac{\color{green}{q_\phi(z|x)}}{\color{purple}{p_\theta(z)}} \right) dz = \text{KL}\left(\color{green}{q_\phi(z|x)} \; || \; \color{purple}{p_\theta(z)}\right)\]</span></p>
<p>The third term is an expectation under <span class="math inline">\(\color{green}{q_\phi(z|x)}\)</span>:</p>
<p><span class="math display">\[\int \color{green}{q_\phi(z|x)} \log(\color{blue}{p_\theta(x|z)}) \, dz = \mathbb{E}_{z \sim \color{green}{q_\phi(z|x)}} \left[ \log(\color{blue}{p_\theta(x|z)}) \right]\]</span></p>
<p>Therefore:</p>
<p><span class="math display">\[\text{KL}\left(\color{green}{q_\phi(z|x)} \; || \; \color{red}{p_\theta(z|x)}\right) = \log(\color{teal}{p_\theta(x)}) + \text{KL}\left(\color{green}{q_\phi(z|x)} \; || \; \color{purple}{p_\theta(z)}\right) - \mathbb{E}_{z \sim \color{green}{q_\phi(z|x)}} \left[ \log(\color{blue}{p_\theta(x|z)}) \right]\]</span></p>
</section>
<section id="step-9-rearrange-to-isolate-the-evidence" class="level4">
<h4 class="anchored" data-anchor-id="step-9-rearrange-to-isolate-the-evidence">Step 9: Rearrange to Isolate the Evidence</h4>
<p>Rearranging the equation:</p>
<p><span class="math display">\[\log(\color{teal}{p_\theta(x)}) = \text{KL}\left(\color{green}{q_\phi(z|x)} \; || \; \color{red}{p_\theta(z|x)}\right) + \underbrace{\mathbb{E}_{z \sim \color{green}{q_\phi(z|x)}} \left[ \log(\color{blue}{p_\theta(x|z)}) \right] - \text{KL}\left(\color{green}{q_\phi(z|x)} \; || \; \color{purple}{p_\theta(z)}\right)}_{\text{ELBO}(\color{blue}{\theta}, \color{green}{\phi}; x)}\]</span></p>
<div class="callout callout-style-default callout-important no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The Evidence Lower Bound (ELBO)
</div>
</div>
<div class="callout-body-container callout-body">
<p>We define the <strong>Evidence Lower Bound</strong> (ELBO) as:</p>
<p><span class="math display">\[\text{ELBO}(\color{blue}{\theta}, \color{green}{\phi}; x) = \mathbb{E}_{z \sim \color{green}{q_\phi(z|x)}} \left[ \log(\color{blue}{p_\theta(x|z)}) \right] - \text{KL}\left(\color{green}{q_\phi(z|x)} \; || \; \color{purple}{p_\theta(z)}\right)\]</span></p>
<p><strong>Why is it called a “lower bound”?</strong></p>
<p>From the equation above: <span class="math display">\[\log(\color{teal}{p_\theta(x)}) = \underbrace{\text{KL}\left(\color{green}{q_\phi(z|x)} \; || \; \color{red}{p_\theta(z|x)}\right)}_{\geq 0} + \text{ELBO}(\color{blue}{\theta}, \color{green}{\phi}; x)\]</span></p>
<p>Since <span class="math inline">\(\text{KL} \geq 0\)</span>, we have: <span class="math display">\[\text{ELBO}(\color{blue}{\theta}, \color{green}{\phi}; x) \leq \log(\color{teal}{p_\theta(x)})\]</span></p>
<p>The ELBO provides a <strong>lower bound</strong> on the log-evidence <span class="math inline">\(\log(\color{teal}{p_\theta(x)})\)</span>!</p>
</div>
</div>
</section>
<section id="step-10-the-vae-loss-function" class="level4">
<h4 class="anchored" data-anchor-id="step-10-the-vae-loss-function">Step 10: The VAE Loss Function</h4>
<p>In practice, we want to <strong>minimize a loss function</strong>. The VAE loss is simply the <strong>negative ELBO</strong>:</p>
<p><span class="math display">\[\mathcal{L}_{\text{VAE}}(\color{blue}{\theta}, \color{green}{\phi}; x) = -\text{ELBO}(\color{blue}{\theta}, \color{green}{\phi}; x)\]</span></p>
<p><span class="math display">\[\boxed{\mathcal{L}_{\text{VAE}}(\color{blue}{\theta}, \color{green}{\phi}; x) = \text{KL}\left(\color{green}{q_\phi(z|x)} \; || \; \color{purple}{p_\theta(z)}\right) - \mathbb{E}_{z \sim \color{green}{q_\phi(z|x)}} \left[ \log(\color{blue}{p_\theta(x|z)}) \right]}\]</span></p>
<p>We seek the optimal parameters:</p>
<p><span class="math display">\[\color{green}{\phi}^*, \color{blue}{\theta}^* = \arg\min_{\color{green}{\phi}, \color{blue}{\theta}} \mathcal{L}_{\text{VAE}}(\color{blue}{\theta}, \color{green}{\phi}; x)\]</span></p>
<div class="callout callout-style-default callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Interpreting the VAE Loss
</div>
</div>
<div class="callout-body-container callout-body">
<p>The VAE loss has two terms:</p>
<ol type="1">
<li><strong>KL Regularization Term</strong>: <span class="math inline">\(\text{KL}\left(\color{green}{q_\phi(z|x)} \; || \; \color{purple}{p_\theta(z)}\right)\)</span>
<ul>
<li>Encourages the encoder’s approximate posterior to stay close to the prior</li>
<li>Acts as a regularizer preventing overfitting</li>
<li>Ensures the latent space has a nice structure</li>
</ul></li>
<li><strong>Reconstruction Term</strong>: <span class="math inline">\(-\mathbb{E}_{z \sim \color{green}{q_\phi(z|x)}} \left[ \log(\color{blue}{p_\theta(x|z)}) \right]\)</span>
<ul>
<li>Encourages the decoder to reconstruct the input accurately</li>
<li>When the decoder outputs Gaussian distributions, this becomes MSE (Mean Squared Error)</li>
<li>When the decoder outputs Bernoulli distributions, this becomes BCE (Binary Cross-Entropy)</li>
</ul></li>
</ol>
<p>It enforces the following properties:</p>
<ul>
<li><strong>Structured latent geometry:</strong> The KL term shapes latent space into a smooth, continuous manifold aligned with the prior.</li>
<li><strong>Smooth interpolation:</strong> Nearby latent points decode to semantically similar outputs, enabling meaningful interpolations.</li>
<li><strong>Valid sampling:</strong> Samples drawn from the prior fall in regions the decoder understands, producing realistic generations.</li>
</ul>
</div>
</div>
<p><strong>Parameter Names:</strong></p>
<ul>
<li><span class="math inline">\(\color{green}{\phi}\)</span> are the <strong>variational parameters</strong> (encoder parameters)</li>
<li><span class="math inline">\(\color{blue}{\theta}\)</span> are the <strong>generative parameters</strong> (decoder parameters)</li>
</ul>
<p><strong>Why This Solves Our Problem:</strong></p>
<p>Maximizing the ELBO (equivalently, minimizing <span class="math inline">\(\mathcal{L}_{\text{VAE}}\)</span>) simultaneously:</p>
<ol type="1">
<li>Increases <span class="math inline">\(\log(\color{teal}{p_\theta(x)})\)</span> (generates more realistic samples)</li>
<li>Decreases <span class="math inline">\(\text{KL}\left(\color{green}{q_\phi(z|x)} \; || \; \color{red}{p_\theta(z|x)}\right)\)</span> (better posterior approximation)</li>
</ol>
<p>And we can compute everything in the ELBO without ever needing the intractable <span class="math inline">\(\color{red}{p_\theta(z|x)}\)</span>!</p>
</section>
</section>
<section id="key-takeaways-and-final-remarks" class="level3">
<h3 class="anchored" data-anchor-id="key-takeaways-and-final-remarks">Key Takeaways and Final Remarks</h3>
<p>The Variational Autoencoder framework provides a principled solution to learning latent variable models when exact inference is intractable. By introducing a tractable variational posterior and optimizing the Evidence Lower Bound (ELBO), we transform an otherwise impossible likelihood maximization problem into a practical and scalable objective that can be optimized with stochastic gradient methods.</p>
<p>From the derivation, several core insights emerge:</p>
<ul>
<li>First, the VAE objective naturally decomposes into two competing terms:
<ul>
<li>A reconstruction term that encourages faithful data generation, via the decoder.</li>
<li>A KL regularization term that shapes the latent space by keeping the approximate posterior close to the prior, via the encoder.</li>
<li>This trade-off is not an implementation detail, but a direct consequence of variational inference.</li>
</ul></li>
<li>Second, maximizing the ELBO simultaneously improves data likelihood and posterior approximation, even though the true posterior is never computed explicitly.</li>
</ul>
<p>This framework extends seamlessly to Conditional VAEs by conditioning both the encoder and decoder on auxiliary information. The mathematical structure of the ELBO remains unchanged, highlighting the flexibility and generality of variational inference as a modeling paradigm.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>